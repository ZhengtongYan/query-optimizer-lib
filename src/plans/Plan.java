package plans;

import static common.Constants.*;

import java.io.Serializable;
import java.util.Arrays;

import common.Constants;
import relations.Relation;

/**
 * Represents a query plan with associated cost vector.
 * 
 * @author immanueltrummer
 *
 */
public abstract class Plan implements Serializable {
	/**
	 * Used to check the class version.
	 */
	private static final long serialVersionUID = 1L;
	/**
	 * Keeps track of the number of partial plans
	 */
	public static long nrPlansCreated = 0;
	/**
	 * Whether cost, sub-plans, etc. can be changed
	 */
	protected boolean immutable = false;
	/**
	 * Execution cost of plan - we often consider multiple plan cost metrics hence
	 * plan cost is represented as a vector where different components represent
	 * cost according to different metrics.
	 */
	public double[] cost = new double[NR_COST_METRICS];
	/**
	 * Cardinality of plan output
	 */
	public final double outputRows;
	/**
	 * Number of disc pages consumed by the result generated by this plan
	 */
	public final double outputPages;
	/**
	 * Whether the output of the plan is materialized (i.e., written to disc)
	 */
	public final boolean materializes;
	/**
	 * The relation (i.e., a set of joined tables) produced by this plan -
	 * this field is not used by all optimizers and may be set to null.
	 */
	public final Relation resultRel;
	/**
	 * The tree height of the query plan.
	 */
	public final int height;
	/**
	 * This constructor is used if no result relations are used.
	 * 
	 * @param outputRows	cardinality of relation produced by this plan
	 * @param outputPages	the number of disc pages consumed by the plan result
	 * @param materializes	whether the result of the plan is written to disc
	 * @param height		the height of the plan tree
	 */
	public Plan(double outputRows, double outputPages, boolean materializes, int height) {
		this.outputRows = outputRows;
		this.outputPages = outputPages;
		this.materializes = materializes;
		this.height = height;
		this.resultRel = null;
		++nrPlansCreated;
	}
	/**
	 * This constructor automatically sets the result relation and extracts required fields.
	 * 
	 * @param resultRel		the result relation created by this plan
	 * @param materializes	whether the result relation is written to disc
	 * @param height		the height of the query plan tree
	 */
	public Plan(Relation resultRel, boolean materializes, int height) {
		this.outputRows = resultRel.cardinality;
		this.outputPages = resultRel.pages;
		this.materializes = materializes;
		this.height = height;
		this.resultRel = resultRel;
		++nrPlansCreated;
	}
	/**
	 * Makes the plan (its cost, operators, sub-plans) immutable
	 */
	public abstract void makeImmutable();
	/**
	 * Sets a cost value for one specific cost metric - this is only possible if the plan is mutable.
	 * 
	 * @param metric		index of the cost metric whose value we want to change
	 * @param costValue		the new cost estimate
	 */
	public void setCostValue(int metric, double costValue) {
		assert(!immutable);
		cost[metric] = costValue;
	}
	/**
	 * Sets cost values for all plan cost metrics at once - this is only possible if the plan is mutable.
	 * 
	 * @param newCost	the new cost value
	 */
	public void setCostValues(double[] newCost) {
		assert(!immutable);
		for (int metricCtr=0; metricCtr<Constants.NR_COST_METRICS; ++metricCtr) {
			cost[metricCtr] = newCost[metricCtr];
		}
	}
	/**
	 * Obtain execution cost estimate for one specific cost metric.
	 * 
	 * @param metric	index of the cost metric that we want to obtain an estimate for
	 * @return			the estimated execution cost according to the given metric
	 */
	public double getCostValue(int metric) {
		return cost[metric];
	}
	/**
	 * Obtain copy of all cost values
	 * 
	 * @return	a vector of cost values (a deep copy of the original)
	 */
	public double[] getCostValuesCopy() {
		return Arrays.copyOf(cost, Constants.NR_COST_METRICS);
	}
	/**
	 * Returns a deep but mutable copy of this plan
	 * 
	 * @return	a deep and mutable plan copy
	 */
	public abstract Plan deepMutableCopy();
	/**
	 * Output join order, operators, and cost.
	 */
	@Override
	public abstract String toString();
	/**
	 * Output join order only.
	 * 
	 * @return	a String showing the order in which tables are joined but not the join operators
	 */
	public abstract String orderToString();
}
